<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>

<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 1: Rasterizer</h1>
<h2 align="middle">YOUR NAME</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>In this homework, I implemented a simple rasterizer capable of rendering 2D vector graphics. The project covered several key graphics programming concepts, including drawing single-color triangles, implementing antialiasing through supersampling, applying transformations, and texture mapping with antialiasing. I particularly found the challenge of optimizing the triangle rasterization process enlightening, as it required a deep understanding of spatial relationships and efficient iteration through pixel data.</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

<p>To rasterize triangles, I employed an algorithm that iterates over each pixel within the triangle's bounding box to determine if the pixel's center lies within the triangle. This process involves calculating the barycentric coordinates for the pixel's center relative to the triangle's vertices. A pixel is colored if its center is determined to be inside the triangle, based on the condition that all barycentric coordinates are positive and sum to less than one.</p>

<p>The algorithm efficiently narrows down the number of pixels to be checked by first calculating the triangle's axis-aligned bounding box. This ensures that only pixels that could potentially lie within the triangle are considered. The barycentric coordinate method allows for an elegant determination of a point's inclusion within the triangle, accommodating the case where points lie exactly on one of the triangle's edges.</p>

<div align="middle">
  <table style="width:100%">
    <tr>
      <td>
        <img src="hw1/screenshot_2-13_19-20-47.png.png" align="middle" width="400px"/>
        <figcaption align="middle">Basic rasterization of a single-color triangle.</figcaption>
      </td>  
    </tr>
  </table>
</div>

<h3 align="middle">Part 2: Antialiasing triangles</h3>
<!-- Future content will go here -->

<h3 align="middle">Part 3: Transforms</h3>
<!-- Future content will go here -->

<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>
<!-- Future content will go here -->

<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>
<!-- Future content will go here -->

<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>
<!-- Future content will go here -->

<h2 align
