<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>

<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 1: Rasterizer</h1>
<h2 align="middle">Heeyong Chung</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>In this homework, I implemented a simple rasterizer capable of rendering 2D vector graphics. The project covered several key graphics programming concepts, including drawing single-color triangles, implementing antialiasing through supersampling, applying transformations, and texture mapping with antialiasing. I particularly found the challenge of optimizing the triangle rasterization process enlightening, as it required a deep understanding of spatial relationships and efficient iteration through pixel data.</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

<p>To rasterize triangles, I employed an algorithm that iterates over each pixel within the triangle's bounding box to determine if the pixel's center lies within the triangle. This process involves calculating the barycentric coordinates for the pixel's center relative to the triangle's vertices. A pixel is colored if its center is determined to be inside the triangle, based on the condition that all barycentric coordinates are positive and sum to less than one.</p>

<p>The algorithm efficiently narrows down the number of pixels to be checked by first calculating the triangle's axis-aligned bounding box. This ensures that only pixels that could potentially lie within the triangle are considered. The barycentric coordinate method allows for an elegant determination of a point's inclusion within the triangle, accommodating the case where points lie exactly on one of the triangle's edges.</p>

<div align="middle">
  <table style="width:100%">
    <tr>
      <td>
        <img src="screenshot_2-13_19-20-47.png" align="middle" width="400px"/>
        <figcaption align="middle">Triangle rasterization for solid triangles of different forms and colors. Default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</figcaption>
      </td>  
    </tr>
  </table>
</div>

<h3 align="middle">Part 2: Antialiasing by Supersampling</h3>
<p>Antialiasing through supersampling is a technique aimed at reducing the visual artifacts at the edges of rendered shapes, notably triangles, to achieve smoother visual outputs. By sampling multiple points within each pixel and averaging their colors, we mitigate the jagged edges commonly observed in rasterized images, resulting in a more visually appealing image. The core of this approach lies in the implementation of a supersampling algorithm alongside the necessary data structures to support high-resolution sampling.</p>

<p>In adapting the rasterization pipeline for supersampling, we introduced a supersampled buffer, effectively rasterizing scenes at a higher resolution. Each pixel's final color is then determined by averaging the colors of the supersamples within it. This process was particularly crucial for triangles, where the edges are most susceptible to aliasing effects. Modifications to the rasterization pipeline included:</p>

<ul>
  <li>Expanding the <code>sample_buffer</code> to hold a higher number of samples.</li>
  <li>Adjusting the <code>rasterize_triangle</code> function to account for supersampling, thus ensuring that each triangle is rasterized at the finer resolution dictated by the supersampling rate.</li>
  <li>Implementing a <code>resolve_to_framebuffer</code> function that averages supersample colors to determine each pixel's final color.</li>
</ul>

<p>Supersampling is useful for its ability to provide a higher-quality rendering of vector graphics, especially evident in the rendering of triangles where edges can otherwise appear jagged due to the aliasing effect. This method significantly improves image quality by providing a more accurate representation of edges and fine details.</p>

<div align="middle">
  <table style="width:100%">
    <tr>
      <th>Sample Rate 1</th>
      <th>Sample Rate 4</th>
      <th>Sample Rate 16</th>
    </tr>
    <tr>
      <td><img src="t2-sample1.png" align="middle" width="300px"/>
          <figcaption align="middle">Sample Rate 1</figcaption></td>
      <td><img src="t2-sample4.png" align="middle" width="300px"/>
          <figcaption align="middle">Sample Rate 4</figcaption></td>
      <td><img src="t2-sample16.png" align="middle" width="300px"/>
          <figcaption align="middle">Sample Rate 16</figcaption></td>
    </tr>
  </table>
</div>

<p>As observed in the screenshots above, increasing the sample rate from 1 to 16 progressively smooths out the edges of the triangles, significantly reducing the aliasing effect. At a sample rate of 1, the edges are quite jagged, while at 16, they are markedly smoother, demonstrating the effectiveness of supersampling in antialiasing. This smoothing effect is due to the averaging process, which blends the color of edge pixels with their background, creating a gradient that visually softens the edge. Such results underscore the importance of supersampling in rendering high-quality vector graphics.</p>


<h3 align="middle">Part 3: Transforms</h3>
<!-- Future content will go here -->

<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric coordinates</h3>
<!-- Future content will go here -->

<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>
<!-- Future content will go here -->

<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>
<!-- Future content will go here -->

<h2 align
