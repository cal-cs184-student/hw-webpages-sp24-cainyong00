<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<style>
  body {
    padding: 100px;
    width: 1000px;
    margin: auto;
    text-align: left;
    font-weight: 300;
    font-family: 'Open Sans', sans-serif;
    color: #121212;
  }
  h1, h2, h3, h4 {
    font-family: 'Source Sans Pro', sans-serif;
  }
</style>
<title>CS 184/284A Rasterizer</title>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<link href="https://fonts.googleapis.com/css?family=Open+Sans|Source+Sans+Pro" rel="stylesheet">
</head>

<body>

<h1 align="middle">CS 184/284A: Computer Graphics and Imaging, Spring 2024</h1>
<h1 align="middle">Homework 1: Rasterizer</h1>
<h2 align="middle">Heeyong Chung</h2>

<br><br>

<div>

<h2 align="middle">Overview</h2>
<p>In this homework, I implemented a simple rasterizer capable of rendering 2D vector graphics. The project covered several key graphics programming concepts, including drawing single-color triangles, implementing antialiasing through supersampling, applying transformations, and texture mapping with antialiasing. I particularly found the challenge of optimizing the triangle rasterization process enlightening, as it required a deep understanding of spatial relationships and efficient iteration through pixel data.</p>

<h2 align="middle">Section I: Rasterization</h2>

<h3 align="middle">Part 1: Rasterizing single-color triangles</h3>

<p>To rasterize triangles, I employed an algorithm that iterates over each pixel within the triangle's bounding box to determine if the pixel's center lies within the triangle. This process involves calculating the barycentric coordinates for the pixel's center relative to the triangle's vertices. A pixel is colored if its center is determined to be inside the triangle, based on the condition that all barycentric coordinates are positive and sum to less than one.</p>

<p>The algorithm efficiently narrows down the number of pixels to be checked by first calculating the triangle's axis-aligned bounding box. This ensures that only pixels that could potentially lie within the triangle are considered. The barycentric coordinate method allows for an elegant determination of a point's inclusion within the triangle, accommodating the case where points lie exactly on one of the triangle's edges.</p>

<div align="middle">
  <table style="width:100%">
    <tr>
      <td>
        <img src="screenshot_2-13_19-20-47.png" align="middle" width="400px"/>
        <figcaption align="middle">Triangle rasterization for solid triangles of different forms and colors. Default viewing parameters and with the pixel inspector centered on an interesting part of the scene.</figcaption>
      </td>  
    </tr>
  </table>
</div>

<h3 align="middle">Part 2: Antialiasing by Supersampling</h3>
<p>Antialiasing through supersampling is a technique aimed at reducing the visual artifacts at the edges of rendered shapes, notably triangles, to achieve smoother visual outputs. By sampling multiple points within each pixel and averaging their colors, we mitigate the jagged edges commonly observed in rasterized images, resulting in a more visually appealing image. The core of this approach lies in the implementation of a supersampling algorithm alongside the necessary data structures to support high-resolution sampling.</p>

<p>In adapting the rasterization pipeline for supersampling, we introduced a supersampled buffer, effectively rasterizing scenes at a higher resolution. Each pixel's final color is then determined by averaging the colors of the supersamples within it. This process was particularly crucial for triangles, where the edges are most susceptible to aliasing effects. Modifications to the rasterization pipeline included:</p>

<ul>
  <li>Expanding the <code>sample_buffer</code> to hold a higher number of samples.</li>
  <li>Adjusting the <code>rasterize_triangle</code> function to account for supersampling, thus ensuring that each triangle is rasterized at the finer resolution dictated by the supersampling rate.</li>
  <li>Implementing a <code>resolve_to_framebuffer</code> function that averages supersample colors to determine each pixel's final color.</li>
</ul>

<p>Supersampling is useful for its ability to provide a higher-quality rendering of vector graphics, especially evident in the rendering of triangles where edges can otherwise appear jagged due to the aliasing effect. This method significantly improves image quality by providing a more accurate representation of edges and fine details.</p>

<div align="middle">
  <table style="width:100%">
    <tr>
      <th>Sample Rate 1</th>
      <th>Sample Rate 4</th>
      <th>Sample Rate 16</th>
    </tr>
    <tr>
      <td><img src="t2-sample1.png" align="middle" width="300px"/>
          <figcaption align="middle">Sample Rate 1</figcaption></td>
      <td><img src="t2-sample4.png" align="middle" width="300px"/>
          <figcaption align="middle">Sample Rate 4</figcaption></td>
      <td><img src="t2-sample16.png" align="middle" width="300px"/>
          <figcaption align="middle">Sample Rate 16</figcaption></td>
    </tr>
  </table>
</div>

<p>As observed in the screenshots above, increasing the sample rate from 1 to 16 progressively smooths out the edges of the triangles, significantly reducing the aliasing effect. At a sample rate of 1, the edges are quite jagged, while at 16, they are markedly smoother, demonstrating the effectiveness of supersampling in antialiasing. This smoothing effect is due to the averaging process, which blends the color of edge pixels with their background, creating a gradient that visually softens the edge. Such results underscore the importance of supersampling in rendering high-quality vector graphics.</p>


<h3 align="middle">Part 3: Transforms</h3>
<p>I wanted to make the robot wave, and I also wanted to change the color of his body to blue and his arms to gold (Cal colors!)</p>
<div align="middle">
  <table style="width:100%">
    <tr>
      <th>Personal Robot</th>
    </tr>
    <tr>
      <td><img src="t3.png" align="middle" width="300px"/>
          <figcaption align="middle">Personal Robot</figcaption></td>
    </tr>
  </table>
</div>
<h2 align="middle">Section II: Sampling</h2>

<h3 align="middle">Part 4: Barycentric Coordinates</h3>
<p>Barycentric coordinates provide a method for expressing the position of a point within a triangle as a weighted average of the triangle's vertices. This system is particularly useful in graphics for interpolating values across the surface of a triangle. Each vertex of the triangle is assigned a barycentric coordinate, with the sum of the coordinates equaling one. A point inside the triangle can then be described by how much it 'leans' towards each vertex, allowing for smooth color gradients and texture mapping.</p>

<p>When rasterizing a triangle with vertex colors, we calculate the barycentric coordinates for each pixel within the triangle. The pixel's color is then a mix of the vertex colors, weighted by these coordinates. This results in a gradient where the color smoothly changes from one vertex color to another, filling the triangle with a blend of colors. This technique is visible in the test7.svg, which displays a single triangle with vertices in red, green, and blue.</p>

<div align="middle">
  <table style="width:100%">
    <tr>
      <th>Barycentric Color Interpolation</th>
    </tr>
    <tr>
      <td><img src="111111.png" align="middle" width="300px"/>
          <figcaption align="middle">Smooth color gradient in a triangle using barycentric coordinates. Sample Rate 1.</figcaption></td>
      <td><img src="t4.png" align="middle" width="300px"/>
          <figcaption align="middle">a colorwheel composed of radially fanning acute isosceles triangles</figcaption></td>
    </tr>
  </table>
</div>

<p>The image above showcases a triangle where the vertices are defined with primary colors: red, green, and blue. Using barycentric coordinates, we interpolate these colors across the triangle's area, resulting in a smooth transition and a rich blend of colors towards the center. This technique demonstrates the power of barycentric coordinates in rendering complex color patterns with simple geometric shapes.</p>

<!-- Rest of the content -->


<h3 align="middle">Part 5: "Pixel sampling" for texture mapping</h3>
<!-- Future content will go here -->

<h3 align="middle">Part 6: "Level sampling" with mipmaps for texture mapping</h3>
<!-- Future content will go here -->

<h2 align
